diff -ur a/omx/gstomxvideoenc.c b/omx/gstomxvideoenc.c
--- a/omx/gstomxvideoenc.c	2022-04-21 10:17:15.000000000 +0900
+++ b/omx/gstomxvideoenc.c	2022-10-18 15:16:39.745173900 +0900
@@ -59,6 +59,11 @@
 static gboolean gst_omx_video_enc_set_use_buffer (GstOMXVideoEnc * self);
 #endif
 
+#ifdef OMX_TARGET_RCAR_RZV2M
+static gboolean
+gst_omx_video_enc_convertI420toNV12 (GstOMXVideoEnc * self, GstVideoFrame * frame, GstOMXBuffer * outbuf);
+#endif
+
 #define GST_TYPE_OMX_VIDEO_ENC_CONTROL_RATE (gst_omx_video_enc_control_rate_get_type ())
 static GType
 gst_omx_video_enc_control_rate_get_type (void)
@@ -2001,8 +2006,10 @@
     if (klass->cdata.hacks & GST_OMX_HACK_RENESAS_ENCMC_STRIDE_ALIGN) {
       switch (port_def.format.video.eColorFormat) {
         case OMX_COLOR_FormatYUV420Planar:
+#ifndef OMX_TARGET_RCAR_RZV2M
           port_def.format.video.nStride = GST_ROUND_UP_64 (stride);
           break;
+#endif
         case OMX_COLOR_FormatYUV420SemiPlanar:
 #ifdef OMX_TARGET_RCAR_RZV2M
           gst_omx_video_calc_power(2, stride, &(port_def.format.video.nStride));
@@ -2024,7 +2031,9 @@
     port_def.format.video.nSliceHeight = slice_height;
 
   switch (port_def.format.video.eColorFormat) {
+#ifndef OMX_TARGET_RCAR_RZV2M
     case OMX_COLOR_FormatYUV420Planar:
+#endif
     case OMX_COLOR_FormatYUV420PackedPlanar:
 #ifdef USE_OMX_TARGET_ZYNQ_USCALE_PLUS
       /* Formats defined in extensions have their own enum so disable to -Wswitch warning */
@@ -2039,6 +2048,9 @@
           ((port_def.format.video.nFrameHeight + 1) / 2));
       break;
 
+#ifdef OMX_TARGET_RCAR_RZV2M
+    case OMX_COLOR_FormatYUV420Planar:
+#endif
     case OMX_COLOR_FormatYUV420PackedSemiPlanar:
     case OMX_COLOR_FormatYUV420SemiPlanar:
       port_def.nBufferSize =
@@ -2289,9 +2301,11 @@
 
   switch (port_def.format.video.eColorFormat) {
     case OMX_COLOR_FormatYUV420Planar:
+#ifndef OMX_TARGET_RCAR_RZV2M    /* RZV2M supported only NV12 */
       port_def.format.video.eColorFormat =
           OMX_COLOR_FormatYUV420PlanarMultiPlane;
       break;
+#endif
     case OMX_COLOR_FormatYUV420SemiPlanar:
       port_def.format.video.eColorFormat =
           OMX_COLOR_FormatYUV420SemiPlanarMultiPlane;
@@ -2624,8 +2638,10 @@
     /* Fallback */
     switch (info->finfo->format) {
       case GST_VIDEO_FORMAT_I420:
+#ifndef OMX_TARGET_RCAR_RZV2M    /* RZV2M supported only NV12 */
         port_def.format.video.eColorFormat = OMX_COLOR_FormatYUV420Planar;
         break;
+#endif
       case GST_VIDEO_FORMAT_NV12:
         port_def.format.video.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
         break;
@@ -2650,6 +2666,14 @@
 
       if (m->format == info->finfo->format) {
         port_def.format.video.eColorFormat = m->type;
+#ifdef OMX_TARGET_RCAR_RZV2M
+        /* RZV2M supported only NV12 */
+        if (OMX_COLOR_FormatYUV420Planar == port_def.format.video.eColorFormat) {
+          port_def.format.video.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanar;
+        } else if (OMX_COLOR_FormatYUV420PlanarMultiPlane == port_def.format.video.eColorFormat) {
+          port_def.format.video.eColorFormat = OMX_COLOR_FormatYUV420SemiPlanarMultiPlane;
+        }
+#endif
         break;
       }
     }
@@ -2932,10 +2956,21 @@
     GST_LOG_OBJECT (self, "Matched strides - direct copy %u bytes",
         (guint) outbuf->omx_buf->nFilledLen);
 
+#ifdef OMX_TARGET_RCAR_RZV2M
+    if (GST_VIDEO_FORMAT_I420 == info->finfo->format) {
+      /* RZV2M supported only NV12 */
+      ret = gst_omx_video_enc_convertI420toNV12 (self, &frame, outbuf);
+      if (FALSE == ret)
+        goto unmap_frame;
+    } else {
+#endif
     gst_buffer_extract (inbuf, 0,
         outbuf->omx_buf->pBuffer + outbuf->omx_buf->nOffset,
         outbuf->omx_buf->nFilledLen);
     ret = TRUE;
+#ifdef OMX_TARGET_RCAR_RZV2M
+    }
+#endif
     goto unmap_frame;
   }
 
@@ -2944,6 +2979,12 @@
 
   switch (info->finfo->format) {
     case GST_VIDEO_FORMAT_I420:{
+#ifdef OMX_TARGET_RCAR_RZV2M
+      /* RZV2M supported only NV12 */
+      ret = gst_omx_video_enc_convertI420toNV12 (self, &frame, outbuf);
+      if (FALSE == ret)
+        goto unmap_frame;
+#else
       gint i, j, height, width;
       guint8 *src, *dest;
       gint src_stride, dest_stride;
@@ -2999,6 +3040,7 @@
               (port_def->format.video.nSliceHeight / 2) *
               (port_def->format.video.nStride / 2);
       }
+#endif
       ret = TRUE;
       break;
     }
@@ -3719,3 +3761,92 @@
 
   return TRUE;
 }
+
+#ifdef OMX_TARGET_RCAR_RZV2M
+static gboolean
+gst_omx_video_enc_convertI420toNV12 (GstOMXVideoEnc * self, GstVideoFrame * frame, GstOMXBuffer * outbuf)
+{
+  /* RZV2M supported only NV12 */
+  GstVideoCodecState *state = gst_video_codec_state_ref (self->input_state);
+  GstVideoInfo *info = &state->info;
+  OMX_PARAM_PORTDEFINITIONTYPE *port_def = &self->enc_in_port->port_def;
+  gboolean ret = TRUE;
+  gint i, j, k, height, width;
+  guint8 *srcY, *srcU, *srcV, *dest;
+  gint src_stride, dest_stride;
+
+  outbuf->omx_buf->nFilledLen = 0;
+
+  dest_stride = GST_ROUND_UP_128(port_def->format.video.nFrameWidth);
+
+  for (i = 0; i < 2; i++) {
+    src_stride = GST_VIDEO_FRAME_COMP_STRIDE (frame, i);
+    /* XXX: Try this if no stride was set */
+    if (dest_stride == 0)
+      dest_stride = src_stride;
+
+    dest = outbuf->omx_buf->pBuffer + outbuf->omx_buf->nOffset;
+    if (i == 0) {
+      srcY = GST_VIDEO_FRAME_COMP_DATA (frame, i);
+      height = GST_VIDEO_FRAME_COMP_HEIGHT (frame, i);
+      width = GST_VIDEO_FRAME_COMP_WIDTH (frame, i);
+
+      if (GST_VIDEO_FORMAT_INFO_BITS (info->finfo) == 10)
+        /* Need ((width + 2) / 3) 32-bits words */
+        width = (width + 2) / 3 * 4;
+
+      if (dest + dest_stride * height >
+          outbuf->omx_buf->pBuffer + outbuf->omx_buf->nAllocLen) {
+        GST_ERROR_OBJECT (self, "Invalid output buffer size");
+        ret = FALSE;
+        break;
+      }
+
+      for (j = 0; j < height; j++) {
+        memcpy (dest, srcY, width);
+        srcY += src_stride;
+        dest += dest_stride;
+      }
+
+      /* nFilledLen should include the vertical padding in each slice (spec 3.1.3.7.1) */
+      outbuf->omx_buf->nFilledLen +=
+          port_def->format.video.nSliceHeight *
+          port_def->format.video.nStride;
+    } else {
+      dest += height * dest_stride;
+      srcU = GST_VIDEO_FRAME_COMP_DATA (frame, i);
+      srcV = GST_VIDEO_FRAME_COMP_DATA (frame, i+1);
+      height = height / 2;
+      width = width / 2;
+
+      if (dest + dest_stride * height >
+          outbuf->omx_buf->pBuffer + outbuf->omx_buf->nAllocLen) {
+        GST_ERROR_OBJECT (self, "Invalid output buffer size");
+        ret = FALSE;
+        break;
+      }
+
+      for (j = 0; j < height; j++) {
+        for (k = 0; k < width; k++) {
+          dest[0] = *srcU;
+          dest[1] = *srcV;
+          srcU++;
+          srcV++;
+          dest += 2;
+        }
+        srcU += src_stride - width;
+        srcV += src_stride - width;
+        dest += dest_stride - (width * 2);
+      }
+
+      /* nFilledLen should include the vertical padding in each slice (spec 3.1.3.7.1) */
+      outbuf->omx_buf->nFilledLen +=
+          port_def->format.video.nSliceHeight / 2 *
+          port_def->format.video.nStride;
+    }
+  }
+
+  return ret;
+}
+#endif
+
