diff --git a/arch/arm64/boot/dts/renesas/r9a09g055ma3gbg.dtsi b/arch/arm64/boot/dts/renesas/r9a09g055ma3gbg.dtsi
index 1bc07cd..9a03df0 100644
--- a/arch/arm64/boot/dts/renesas/r9a09g055ma3gbg.dtsi
+++ b/arch/arm64/boot/dts/renesas/r9a09g055ma3gbg.dtsi
@@ -1148,6 +1148,11 @@
             resets = <&cpg 1000>;
             status = "disabled";
         };
+        drpopencva@c7800000 {
+            compatible = "renesas,rzv2ma-drpopencva";
+            reg = <0x00 0x78000000 0x00 0x00>;
+            status = "okay";
+        };
     };
 
     thermal-zones {
diff --git a/drivers/Makefile b/drivers/Makefile
index e2e3824..9881987 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -192,3 +192,4 @@ obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
 obj-$(CONFIG_DRPAI)		+= drpai/
 obj-$(CONFIG_DRP)		+= drpai/
+obj-$(CONFIG_DRPOPENCVA)	+= drpai/
diff --git a/drivers/drpai/Kconfig b/drivers/drpai/Kconfig
index 6a776c5..d990d5e 100644
--- a/drivers/drpai/Kconfig
+++ b/drivers/drpai/Kconfig
@@ -18,4 +18,10 @@ config DRP
 	  DRP is a peripheral hardware that accelerates image processing.
 	  If you want DRP support, you should say Y here.
 
+config DRPOPENCVA
+	tristate "DRPOPENCVA support"
+	default y
+	help
+	  DRP is a peripheral hardware that accelerates image processing.
+	  If you want DRPOPENCVA support, you should say Y here.
 endmenu
diff --git a/drivers/drpai/Makefile b/drivers/drpai/Makefile
index c289fe0..f21198c 100644
--- a/drivers/drpai/Makefile
+++ b/drivers/drpai/Makefile
@@ -3,7 +3,6 @@
 # Makefile for DRP-AI/DRP.
 #
 
-obj-$(CONFIG_DRPAI)	+= drpai-core.o drpai-if.o
-obj-$(CONFIG_DRP)	+= drpai-core.o drp-if.o
-
-
+obj-$(CONFIG_DRPAI)		+= drpai-core.o drpai-if.o
+obj-$(CONFIG_DRP)		+= drpai-core.o drp-if.o
+obj-$(CONFIG_DRPOPENCVA)	+= opencva.o
diff --git b/drivers/drpai/opencva.c b/drivers/drpai/opencva.c
new file mode 100644
index 0000000..7967fdb
--- /dev/null
+++ b/drivers/drpai/opencva.c
@@ -0,0 +1,319 @@
+/***********************************************************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
+* other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
+* applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
+* EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
+* SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
+* SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
+* this software. By using this software, you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+*
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : opencva.c
+* Version      : 1.00
+* Description  : OpenCVA Device Driver
+***********************************************************************************************************************/
+/*****************************************
+* Includes
+******************************************/
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+
+/*****************************************
+* license information and define values
+******************************************/
+#define DRIVER_NAME "drpopencva"                        // device name within /proc/devices
+#define OPENCV_BIN_PATH "/etc/opencva/OpenCV_Bin.bin"   // path to opencv binary
+
+#define CMD_GET_ADDRESS 0
+#define CMD_GET_BINDATA 1
+#define CMD_READ_OPENCVBIN 2
+
+/*****************************************
+* Global Variables
+******************************************/
+static uint32_t opencv_bin_addr32_phy = 0x0;            
+static uint64_t opencv_bin_addr64_phy = 0x0;            
+
+static const unsigned int MINOR_BASE = 0;       /* start number of minor no */
+static const unsigned int MINOR_NUM  = 1;       /* minor no */
+static unsigned int opencvadrv_major;           /* major no (dynamic) */
+static struct cdev opencvadrv_cdev;             /* charactor device */
+static struct class *opencvadrv_class = NULL;   /* class object */
+
+static uint8_t opencv_bin_p[4194304];   // 4M Byte
+
+/*****************************************
+* Function Name : opencva_open
+* Description   : call back to device open(in this version not implemented)
+* Arguments     : struct inode, struct
+* Return value  : 0
+******************************************/
+static int opencva_open(struct inode *inode, struct file *file)
+{
+        return 0;
+}
+
+/*****************************************
+* Function Name : opencva_close
+* Description   : call back to device close(in this version not implemented)
+* Arguments     : struct inode, struct
+* Return value  : 0
+******************************************/
+static int opencva_close(struct inode *inode, struct file *file)
+{
+        return 0;
+}
+
+/*****************************************
+* Function Name : opencvbin_init
+* Description   : reading and initializing opencva binary file
+* Arguments     : void
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+int opencvbin_init(void)
+{
+    struct file *fp;
+    int ret = 0;
+    mm_segment_t fs;
+    uint8_t *kfile_buf = NULL;
+    uint32_t mpos = 0;
+
+    char sign[16];
+
+    uint64_t opencv_bin_vaddress = 0x0;
+
+    /* To write/read file in kernel, vitural file system has to change from user to kernel*/
+    fs = get_fs();
+    set_fs(KERNEL_DS);
+
+    /* Open the file and obtain file size */
+    fp = filp_open(OPENCV_BIN_PATH, O_RDONLY, 0444);
+    if (IS_ERR(fp))
+    {
+        printk(KERN_INFO "opencva bin openerr.\n");
+        return -1;
+    }
+    printk(KERN_INFO "opencva bin opened.\n");
+
+    mpos = vfs_llseek(fp, 0, SEEK_END);
+    vfs_llseek(fp, 0, 0);
+    printk("File size : %d", mpos);
+
+    kfile_buf = vmalloc((uint32_t) mpos);
+    if(NULL == kfile_buf)
+    {
+        return -1;
+    }
+
+    ret = kernel_read(fp, kfile_buf, mpos , &fp->f_pos);
+    opencv_bin_vaddress = (uint64_t)phys_to_virt(opencv_bin_addr64_phy);
+        
+    memcpy((void*)opencv_bin_vaddress, kfile_buf, mpos);
+    memcpy((void*)opencv_bin_p, kfile_buf, (uint32_t) mpos);
+
+    memcpy((void*)sign, opencv_bin_p, 16);
+    printk(KERN_INFO "sign = %s\n", sign);
+
+    /* Change the vfs back to user */
+    set_fs(fs);
+    if (NULL != kfile_buf)
+    {
+        vfree(kfile_buf);
+    }
+    if (NULL != fp)
+    {
+        filp_close(fp, NULL);
+    }
+
+    return 0;
+}
+
+/*****************************************
+* Function Name : opencva_ioctl
+* Description   : call back to device close
+* Arguments     : struct inode, struct
+* Return value  : 0 if succeeded
+*                 not 0 otherwise
+******************************************/
+static long opencva_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+        switch (cmd)
+         {
+        case CMD_GET_ADDRESS:
+               if (copy_to_user((void __user *)arg, &opencv_bin_addr32_phy, sizeof(opencv_bin_addr32_phy)))
+                {
+                        return -1; 
+                }
+               break;
+
+        case CMD_GET_BINDATA:
+               opencvbin_init(); 
+               if (copy_to_user((void __user *)arg, opencv_bin_p, sizeof(opencv_bin_p)))
+                {
+                        return -1; 
+                }
+               break;
+
+	case CMD_READ_OPENCVBIN:
+               break;
+        
+       default:
+               break;
+        }
+
+        return 0;
+}
+
+static struct file_operations opencvadrv_fops = {
+        .open    = opencva_open,
+        .release = opencva_close,
+        .unlocked_ioctl = opencva_ioctl,
+};
+
+/*****************************************
+* Function Name : driver_init
+* Description   : creating device file and special files
+* Arguments     : void
+* Return value  : void 
+******************************************/
+void opencva_driver_init(void)
+{
+    int alloc_ret = 0;
+    int cdev_err = 0;
+    dev_t dev;
+        
+    int minor = 0;
+    int ret = 0;
+
+    struct device_node *node = NULL;
+    uint32_t addr[] = {0,0,0,0};
+
+    printk("driver init\n");
+
+    node = of_find_compatible_node(NULL, NULL, "renesas,rzv2ma-drpopencva");
+    if(node)
+    {
+        ret = of_property_read_u32_array(node , "reg", addr, ARRAY_SIZE(addr));
+        if (0 != ret)
+        {
+            return;
+        }
+
+        opencv_bin_addr64_phy = addr[3];
+        opencv_bin_addr64_phy = opencv_bin_addr64_phy << 32;
+        opencv_bin_addr64_phy = opencv_bin_addr64_phy + addr[1];
+        opencv_bin_addr32_phy = addr[1];
+    }
+    else
+    {
+       return; 
+    }
+
+    // to get valid major no 
+    alloc_ret = alloc_chrdev_region(&dev, MINOR_BASE, MINOR_NUM, DRIVER_NAME);
+    if (alloc_ret != 0) {
+        return;
+    }
+
+    // to keep major no
+    opencvadrv_major = MAJOR(dev);
+    dev = MKDEV(opencvadrv_major, MINOR_BASE);
+
+    // to regist handler table 
+    cdev_init(&opencvadrv_cdev, &opencvadrv_fops);
+    opencvadrv_cdev.owner = THIS_MODULE;
+
+    // to regist to kernel
+    cdev_err = cdev_add(&opencvadrv_cdev, dev, MINOR_NUM);
+    if (cdev_err != 0) {
+        unregister_chrdev_region(dev, MINOR_NUM);
+        return;
+    }
+
+    // to create /sys/class/mydevice/ 
+    opencvadrv_class = class_create(THIS_MODULE, DRIVER_NAME);
+    if (IS_ERR(opencvadrv_class)) {
+        cdev_del(&opencvadrv_cdev);
+        unregister_chrdev_region(dev, MINOR_NUM);
+        return;
+    }
+
+    /* to create /sys/class/mydevice/mydevice* */
+    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
+        device_create(opencvadrv_class, NULL, MKDEV(opencvadrv_major, minor), 
+                                        NULL, "%s%d", DRIVER_NAME, minor);
+    }
+
+    return;
+}
+
+/*****************************************
+* Function Name : opencvadrv_init
+* Description   : callback for initial procedure of this device module
+* Arguments     : void
+* Return value  : void 
+******************************************/
+static int opencvadrv_init(void)
+{
+        opencva_driver_init();
+
+        ///opencvbin_init();
+
+        return 0;
+}
+
+/*****************************************
+* Function Name : opencvadrv_exit
+* Description   : callback for unload(rmmod) 
+* Arguments     : void
+* Return value  : void 
+******************************************/
+static void opencvadrv_exit(void)
+{
+        int minor = 0;
+        dev_t dev; 
+
+        dev = MKDEV(opencvadrv_major, MINOR_BASE);
+        
+        /* to remove /sys/class/mydevice/mydevice* */
+        for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
+            device_destroy(opencvadrv_class, MKDEV(opencvadrv_major, minor));
+         }
+
+        /* to remove class register (/sys/class/mydevice/) */
+        class_destroy(opencvadrv_class);
+
+        /* to remove cdev from kernel */
+        cdev_del(&opencvadrv_cdev);
+
+        /* to remove major no of this device */
+        unregister_chrdev_region(dev, MINOR_NUM);
+}
+
+static const struct of_device_id drpopencva_of_match_table[] = {
+    {.compatible = "renesas,drpopencva",},
+    { },
+};
+MODULE_DEVICE_TABLE(of, drpopencva_of_match_table);
+
+module_init(opencvadrv_init);
+module_exit(opencvadrv_exit);
+
+MODULE_DESCRIPTION("RZ/V2MA DRP-Opencva driver");
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
